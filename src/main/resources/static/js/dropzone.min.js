"use strict";

function _typeof(e) {
    return "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }(e)
}

function _possibleConstructorReturn(e, t) {
    return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t
}

function _getPrototypeOf(e) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__ || Object.getPrototypeOf(e)
}

function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function _inherits(e, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), t && _setPrototypeOf(e, t)
}

function _setPrototypeOf(e, t) {
    return Object.setPrototypeOf || (e.__proto__ = t, e)
}

function _classCallCheck(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function _defineProperties(e, t) {
    for (var n = 0; n < t.length; n++) {
        var i = t[n];
        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
    }
}

function _createClass(e, t, n) {
    return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e
}

var Emitter = function () {
    function e() {
        _classCallCheck(this, e)
    }

    return _createClass(e, [{
        key: "on", value: function (e, t) {
            return this._callbacks = this._callbacks || {}, this._callbacks[e] || (this._callbacks[e] = []), this._callbacks[e].push(t), this
        }
    }, {
        key: "emit", value: function (e) {
            this._callbacks = this._callbacks || {};
            var t = this._callbacks[e];
            if (t) {
                for (var n = arguments.length, i = new Array(1 < n ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                var o = !0, a = !1, l = void 0;
                try {
                    for (var s, u = t[Symbol.iterator](); !(o = (s = u.next()).done); o = !0) s.value.apply(this, i)
                } catch (e) {
                    a = !0, l = e
                } finally {
                    try {
                        o || null == u.return || u.return()
                    } finally {
                        if (a) throw l
                    }
                }
            }
            return this
        }
    }, {
        key: "off", value: function (e, t) {
            if (!this._callbacks || 0 === arguments.length) return this._callbacks = {}, this;
            var n = this._callbacks[e];
            if (!n) return this;
            if (1 === arguments.length) return delete this._callbacks[e], this;
            for (var i = 0; i < n.length; i++) if (n[i] === t) {
                n.splice(i, 1);
                break
            }
            return this
        }
    }]), e
}(), Dropzone = function () {
    function C(e, t) {
        var n, i, r;
        if (_classCallCheck(this, C), (n = _possibleConstructorReturn(this, _getPrototypeOf(C).call(this))).element = e, n.version = C.version, n.defaultOptions.previewTemplate = n.defaultOptions.previewTemplate.replace(/\n*/g, ""), n.clickableElements = [], n.listeners = [], n.files = [], "string" == typeof n.element && (n.element = document.querySelector(n.element)), !n.element || null == n.element.nodeType) throw new Error("Invalid dropzone element.");
        if (n.element.dropzone) throw new Error("Dropzone already attached.");
        C.instances.push(_assertThisInitialized(n)), n.element.dropzone = _assertThisInitialized(n);
        var o = null != (r = C.optionsForElement(n.element)) ? r : {};
        if (n.options = C.extend({}, n.defaultOptions, o, null != t ? t : {}), n.options.forceFallback || !C.isBrowserSupported()) return _possibleConstructorReturn(n, n.options.fallback.call(_assertThisInitialized(n)));
        if (null == n.options.url && (n.options.url = n.element.getAttribute("action")), !n.options.url) throw new Error("No URL provided.");
        if (n.options.acceptedFiles && n.options.acceptedMimeTypes) throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
        if (n.options.uploadMultiple && n.options.chunking) throw new Error("You cannot set both: uploadMultiple and chunking.");
        return n.options.acceptedMimeTypes && (n.options.acceptedFiles = n.options.acceptedMimeTypes, delete n.options.acceptedMimeTypes), null != n.options.renameFilename && (n.options.renameFile = function (e) {
            return n.options.renameFilename.call(_assertThisInitialized(n), e.name, e)
        }), n.options.method = n.options.method.toUpperCase(), (i = n.getExistingFallback()) && i.parentNode && i.parentNode.removeChild(i), !1 !== n.options.previewsContainer && (n.options.previewsContainer ? n.previewsContainer = C.getElement(n.options.previewsContainer, "previewsContainer") : n.previewsContainer = n.element), n.options.clickable && (!0 === n.options.clickable ? n.clickableElements = [n.element] : n.clickableElements = C.getElements(n.options.clickable, "clickable")), n.init(), n
    }
    return C
}();
